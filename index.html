<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>doublePen Physics Demo — Attach/Detach</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height: 100%; margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: #111; color: #eee; }
    .app { display: flex; height: 100%; }
    .canvas-wrap { flex: 1; display:flex; align-items:center; justify-content:center; padding: 12px; }
    canvas { background: linear-gradient(180deg,#0b1220,#071019); border-radius:8px; box-shadow: 0 6px 30px rgba(0,0,0,0.6); max-width:100%; max-height:100%; }
    .sidebar { width: 340px; background:#0f1720; padding:16px; box-sizing:border-box; border-left:1px solid rgba(255,255,255,0.03); overflow:auto; }
    h1 { font-size:18px; margin:0 0 12px 0; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
    button, select, input[type=range] { background:#0b1320; color:#fff; border:1px solid rgba(255,255,255,0.06); padding:8px 10px; border-radius:6px; cursor:pointer; }
    button.primary { background:linear-gradient(180deg,#1b6fff,#154fe0); border: none; }
    .info { font-size:13px; color:#bfc7d4; margin-bottom:12px; }
    .list { font-size:13px; margin-top:8px; }
    .item { padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; }
    .item .meta { font-size:12px; color:#9aa7b9; }
    .small { font-size:12px; color:#9aa7b9; }
    footer { margin-top:12px; font-size:12px; color:#89a; }
    .download { margin-top:8px; display:flex; gap:8px; }
    .hint { font-size:12px; color:#6f7c8b; margin-top:8px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <canvas id="viewport" width="900" height="600" aria-label="Physics viewport"></canvas>
    </div>

    <aside class="sidebar" aria-labelledby="title">
      <h1 id="title">Physics demo — Attach / Detach</h1>
      <div class="info">
        Click to create balls. Drag to move. Select an object from the list and use Attach/Detach controls.
      </div>

      <div class="controls">
        <button id="spawnBall" class="primary">Spawn Ball</button>
        <button id="spawnAnchor">Spawn Anchor</button>
        <button id="clear">Clear</button>
      </div>

      <div class="controls">
        <button id="attachBtn">Attach Selected → Target</button>
        <button id="detachBtn">Detach Selected</button>
      </div>

      <div style="margin-top:12px;">
        <label class="small">Simulation dt: <span id="dtVal">0.001</span> s</label>
        <input id="dtRange" type="range" min="0.0001" max="0.02" step="0.0001" value="0.001" />
      </div>

      <div class="list" id="objectList" aria-live="polite"></div>

      <div class="download">
        <button id="downloadScript">Download script.js</button>
        <button id="copyScript">Copy script.js to clipboard</button>
      </div>

      <div class="hint">
        Demo implements a simplified 2D physics core with attach/detach semantics. Attaching snaps a
        child to a named attach point of the target; e.g., "center" for Ball and "anchor" for Anchor.
      </div>

      <footer>doublePen — physicsEngine.js demo</footer>
    </aside>
  </div>

  <script>
/*
  The page contains an inline implementation of a small physics engine mirroring
  the Python engine. It also exposes the entire script content so you can download
  a separate `script.js` file when needed.
*/

const scriptJsContent = `// script.js — extracted runtime for the demo
// Lightweight 2D physics core with attach/detach behavior.

class Vec {
  static add(a,b){ return [a[0]+b[0], a[1]+b[1]]; }
  static sub(a,b){ return [a[0]-b[0], a[1]-b[1]]; }
  static scale(a,s){ return [a[0]*s,a[1]*s]; }
  static len(a){ return Math.hypot(a[0],a[1]); }
  static zero(){ return [0,0]; }
}

class PhysicsObject {
  constructor({position=[0,0], velocity=[0,0], mass=1, color=[200,200,200], fixed=false} = {}) {
    this.position = position.slice();
    this.velocity = velocity.slice();
    this.mass = mass;
    this.color = color;
    this.fixed = fixed;

    // attachment state
    this._attached_to = null;
    this._attached_part = null;
    this._attached_offset = null;
    this._previous_fixed_state = null;
  }

  applyForce(force, dt) {
    if (this.fixed || this._attached_to) return;
    if (this.mass <= 0) return;
    const ax = force[0]/this.mass, ay = force[1]/this.mass;
    this.velocity[0] += ax * dt;
    this.velocity[1] += ay * dt;
  }

  integrate(dt) {
    if (this._attached_to) {
      const target = this._attached_to;
      const part = this._attached_part || 'center';
      const attachPoint = target.getAttachPoint(part);
      if (!attachPoint) return;
      if (this._attached_offset == null) {
        this.position = attachPoint.slice();
      } else {
        this.position = Vec.add(attachPoint, this._attached_offset);
      }
      // inherit velocity for kinematic coupling
      this.velocity = target.velocity.slice();
      return;
    }
    if (this.fixed) return;
    this.position[0] += this.velocity[0] * dt;
    this.position[1] += this.velocity[1] * dt;
  }

  getAttachPoint(part) {
    if (part === 'center') return this.position;
    throw new Error(\`\${this.constructor.name} has no attach point '\${part}'\`);
  }

  attachTo(target, targetPart='center') {
    if (!target) throw new Error('target required');
    const attachPoint = target.getAttachPoint(targetPart);
    // store prior fixed state
    this._previous_fixed_state = this.fixed;
    const offset = Vec.sub(this.position, attachPoint);
    this._attached_to = target;
    this._attached_part = targetPart;
    this._attached_offset = offset;
    // treat as non-dynamic while attached
    this.fixed = true;
  }

  detach() {
    if (!this._attached_to) return;
    const old = this._attached_to;
    // inherit target's velocity for smooth transition
    this.velocity = old.velocity.slice();
    this._attached_to = null;
    this._attached_part = null;
    this._attached_offset = null;
    if (this._previous_fixed_state !== null) {
      this.fixed = this._previous_fixed_state;
      this._previous_fixed_state = null;
    } else {
      this.fixed = false;
    }
  }

  // aliases
  attach_to(target, targetPart='center'){ return this.attachTo(target,targetPart); }
  detachFrom(){ return this.detach(); }
  isAttached(){ return this._attached_to != null; }
}

class Anchor extends PhysicsObject {
  constructor(position=[0,0]) {
    super({position, velocity:[0,0], mass: Infinity, fixed: true, color:[255,80,80]});
  }
  getAttachPoint(part) {
    if (part === 'anchor' || part === 'center') return this.position;
    throw new Error('Anchor missing part ' + part);
  }
}

class Ball extends PhysicsObject {
  constructor({position=[0,0], radius=12, mass=1, color=[160,200,255]} = {}) {
    super({position, velocity:[0,0], mass, color});
    this.radius = radius;
  }
  getAttachPoint(part) {
    if (part === 'center') return this.position;
    throw new Error('Ball missing part ' + part);
  }
}

class RodSpring {
  constructor(a,b,{rest_length=null, stiffness=120, damping=0.0} = {}) {
    this.a = a; this.b = b;
    this.rest_length = rest_length != null ? rest_length : Vec.len(Vec.sub(b.position, a.position));
    this.stiffness = stiffness;
    this.damping = damping;
  }
  apply(dt) {
    const delta = Vec.sub(this.b.position, this.a.position);
    const dist = Vec.len(delta);
    if (dist === 0) return;
    const dir = [ delta[0]/dist, delta[1]/dist ];
    const stretch = dist - this.rest_length;
    const forceMag = -this.stiffness * stretch;
    const relVel = Vec.sub(this.b.velocity, this.a.velocity);
    const dampingForce = -this.damping * (relVel[0]*dir[0] + relVel[1]*dir[1]);
    const total = forceMag + dampingForce;
    const force = Vec.scale(dir, total);
    this.a.applyForce(Vec.scale(force,-1), dt);
    this.b.applyForce(force, dt);
  }
}

function step(objects, constraints, dt) {
  for (let c of constraints) c.apply(dt);
  for (let o of objects) o.integrate(dt);
}

// Expose as module-like for downloaded script usage
export {
  Vec, PhysicsObject, Anchor, Ball, RodSpring, step
};
`;

// The demo below uses the same logic as scriptJsContent, but embedded so the page runs standalone.

(() => {
  // Canvas & rendering setup
  const canvas = document.getElementById('viewport');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = canvas.width, H = canvas.height;

  function resize() {
    // keep fixed size for demo; could be made responsive
  }
  resize();

  // Simulation state
  const objects = [];
  const constraints = [];
  let simDt = 0.001;

  // Utilities to create objects
  function addAnchor(x,y) {
    const a = new Anchor([x,y]);
    objects.push(a);
    return a;
  }
  function addBall(x,y,r=14,m=1) {
    const b = new Ball({position:[x,y], radius:r, mass:m});
    // small random velocity for visual interest
    b.velocity = [ (Math.random()-0.5)*40, (Math.random()-0.5)*40 ];
    objects.push(b);
    return b;
  }

  // Create a floor anchor for demonstration
  addAnchor(W*0.5, H*0.2);
  // spawn a couple of balls
  addBall(W*0.5 + 120, H*0.2 + 20);
  addBall(W*0.5 + 260, H*0.2 + 40);

  // Interaction state
  let selectedId = null;   // index in objects
  let targetId = null;
  const listEl = document.getElementById('objectList');

  function refreshList() {
    listEl.innerHTML = '';
    objects.forEach((o,i) => {
      const div = document.createElement('div');
      div.className = 'item';
      const left = document.createElement('div');
      left.innerHTML = \`<strong>\${i}</strong> <span class="meta">(\${o.constructor.name})</span>\`;
      const right = document.createElement('div');
      right.innerHTML = \`
        <span class="meta">\${o.position.map(v=>v.toFixed(1)).join(',')}</span>
        <button data-i="\${i}" style="margin-left:8px">Select</button>
      \`;
      div.appendChild(left); div.appendChild(right);
      listEl.appendChild(div);
      right.querySelector('button').addEventListener('click', ()=> {
        selectedId = i;
        render(); // highlight selection
        refreshList();
      });
      if (selectedId === i) {
        div.style.background = 'linear-gradient(90deg, rgba(26,115,232,0.12), rgba(255,255,255,0.01))';
      }
    });
  }
  refreshList();

  // Basic mouse handling for spawn & drag
  let dragging = null, dragOffset = [0,0];

  canvas.addEventListener('mousedown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    // Check if clicked an object (nearest within radius)
    let hit = null;
    for (let i = objects.length-1; i>=0; i--) {
      const o = objects[i];
      const dx = o.position[0]-x, dy = o.position[1]-y;
      const r = o.radius || 10;
      if (dx*dx + dy*dy <= r*r) { hit = i; break; }
    }
    if (hit != null) {
      dragging = hit;
      const o = objects[hit];
      dragOffset = [ o.position[0] - x, o.position[1] - y ];
      selectedId = hit;
      refreshList();
    } else {
      // spawn ball
      const b = addBall(x,y,14,1);
      refreshList();
    }
  });

  canvas.addEventListener('mousemove', (ev) => {
    if (dragging == null) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const o = objects[dragging];
    o.position = [ x + dragOffset[0], y + dragOffset[1] ];
    o.velocity = [0,0];
  });

  canvas.addEventListener('mouseup', ()=> { dragging = null; });

  // Controls
  document.getElementById('spawnBall').addEventListener('click', ()=> {
    addBall(Math.random()*W, Math.random()*H, 14, 1);
    refreshList();
  });
  document.getElementById('spawnAnchor').addEventListener('click', ()=> {
    addAnchor(Math.random()*(W-200)+100, Math.random()*(H-200)+100);
    refreshList();
  });
  document.getElementById('clear').addEventListener('click', ()=> {
    objects.length = 0; constraints.length = 0; selectedId = null;
    refreshList();
  });

  document.getElementById('attachBtn').addEventListener('click', ()=> {
    if (selectedId == null) { alert('Select a source object first (in the list)'); return; }
    // pick target via prompt (or default to first Anchor/other)
    const choices = objects.map((o,i) => \`\${i}:\${o.constructor.name}\`).join('\\n');
    const ans = prompt('Enter target id and attach point. Example: 0 anchor\\nAvailable objects:\\n' + choices + '\\n(attach point: center/anchor/ etc)');
    if (!ans) return;
    const parts = ans.trim().split(/\\s+/);
    const tid = parseInt(parts[0],10);
    const partName = parts[1] || 'center';
    if (Number.isNaN(tid) || tid < 0 || tid >= objects.length) { alert('Invalid target id'); return; }
    const src = objects[selectedId], tgt = objects[tid];
    try {
      src.attachTo(tgt, partName);
      alert('Attached object ' + selectedId + ' to ' + tid + ' part ' + partName);
    } catch(e) {
      alert('Attach failed: ' + e.message);
    }
    refreshList();
  });

  document.getElementById('detachBtn').addEventListener('click', ()=> {
    if (selectedId == null) { alert('Select an object first'); return; }
    const src = objects[selectedId];
    src.detach();
    refreshList();
  });

  const dtRange = document.getElementById('dtRange');
  const dtVal = document.getElementById('dtVal');
  dtRange.addEventListener('input', ()=> {
    simDt = parseFloat(dtRange.value);
    dtVal.textContent = simDt.toFixed(4);
  });

  document.getElementById('downloadScript').addEventListener('click', ()=>{
    const blob = new Blob([scriptJsContent], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'script.js';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  document.getElementById('copyScript').addEventListener('click', async ()=>{
    try {
      await navigator.clipboard.writeText(scriptJsContent);
      alert('script.js copied to clipboard');
    } catch(err) {
      alert('Copy failed: ' + err);
    }
  });

  // Basic physics forces: gravity + simple damping
  const gravity = [0, 300]; // px/s^2
  const globalDamping = 0.998;

  function simStep(dt) {
    // apply gravity & damping
    for (let o of objects) {
      if (!o.fixed && !o._attached_to) {
        o.applyForce([ gravity[0]*o.mass, gravity[1]*o.mass ], dt);
        o.velocity[0] *= globalDamping;
        o.velocity[1] *= globalDamping;
      }
    }
    // constraints (springs)
    for (let c of constraints) c.apply(dt);
    // integrate
    for (let o of objects) o.integrate(dt);
    // simple ground collision
    for (let o of objects) {
      if (o.radius) {
        const r = o.radius;
        if (o.position[1] + r > H) {
          o.position[1] = H - r;
          if (o.velocity[1] > 0) o.velocity[1] *= -0.5;
        }
        if (o.position[0] - r < 0) { o.position[0] = r; o.velocity[0] *= -0.6; }
        if (o.position[0] + r > W) { o.position[0] = W - r; o.velocity[0] *= -0.6; }
      }
    }
  }

  function render() {
    ctx.clearRect(0,0,W,H);
    // background gradient fill
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#0b1220"); g.addColorStop(1, "#071019");
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // draw constraints (springs)
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(120,180,255,0.6)';
    for (let c of constraints) {
      ctx.beginPath();
      ctx.moveTo(c.a.position[0], c.a.position[1]);
      ctx.lineTo(c.b.position[0], c.b.position[1]);
      ctx.stroke();
    }

    // draw objects
    for (let i = 0; i < objects.length; i++) {
      const o = objects[i];
      if (o instanceof Anchor) {
        ctx.fillStyle = 'rgb(255,90,90)';
        ctx.beginPath();
        ctx.arc(o.position[0], o.position[1], 8, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = '11px system-ui'; ctx.fillText('A', o.position[0]-4, o.position[1]+4);
      } else if (o.radius) {
        ctx.fillStyle = 'rgba(150,200,255,0.95)';
        ctx.beginPath();
        ctx.arc(o.position[0], o.position[1], o.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; ctx.stroke();
      } else {
        ctx.fillStyle = 'rgba(200,200,200,0.9)';
        ctx.fillRect(o.position[0]-8, o.position[1]-8, 16, 16);
      }

      // highlight selected
      if (selectedId === i) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,220,80,0.95)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(o.position[0], o.position[1], (o.radius || 10) + 6, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // attached badge
      if (o._attached_to) {
        ctx.fillStyle = 'rgba(255,200,80,0.95)';
        ctx.font = '12px system-ui';
        const label = 'attached';
        ctx.fillText(label, o.position[0] + (o.radius || 10) + 6, o.position[1] - 2);
      }
    }
  }

  // Start loop
  let last = performance.now();
  function frame(t) {
    const dt = simDt; // fixed-step for simplicity
    simStep(dt);
    render();
    last = t;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Expose some things for console experimentation
  window._sim = { objects, constraints, addBall, addAnchor, step: simStep, render };
})();
  </script>
</body>
</html>
